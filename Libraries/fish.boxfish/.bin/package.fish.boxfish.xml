<?xml version="1.0"?>
<doc>
    <assembly>
        <name>package.fish.boxfish</name>
    </assembly>
    <members>
        <member name="T:Boxfish.BaseVoxelVolume`2">
            <summary>
            The abstract component, you can decide what kind of voxel structure you want.
            <para>Don't use this if you don't understand it, see <see cref="!:Components.VoxelVolume"/> instead.</para>
            </summary>
            <typeparam name="T">The voxel structure that you want to use. Example: <see cref="!:Components.Voxel"/>.</typeparam>
            <typeparam name="U">The vertex structure that you want to use. Example: <see cref="!:Components.VoxelVertex"/></typeparam>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Chunks">
            <summary>
            Our container of chunks in this volume.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.SetChunks(System.Collections.Generic.Dictionary{Vector3Int,Boxfish.BaseVoxelVolume{`0,`1}.Chunk})">
            <summary>
            Call this method to override the chunks of this voxel volume.
            </summary>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.Chunk">
            <summary>
            Our chunk structure, contains a 3-dimensional array of voxels.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Chunk.Flatten(System.Byte,System.Byte,System.Byte)">
            <summary>
            Flattens the 3D-coordinates into an index of our voxel array.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Chunk.RelativeQuery(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:Boxfish.BaseVoxelVolume`2.Query(System.Int32,System.Int32,System.Int32,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)"/>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Chunk.SetVoxel(System.Byte,System.Byte,System.Byte,`0)">
            <summary>
            Set voxel in local position 
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="voxel"></param>
            <exception cref="T:System.IndexOutOfRangeException">When accessing outside of the 0-15 range.</exception>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Chunk.GetNeighbors(System.Byte,System.Byte,System.Byte,System.Boolean)">
            <summary>
            Get neighbors depending on the local position given in the parameters.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="includeSelf"></param>
            <returns></returns>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.StoreEditorChunks">
            <summary>
            Do we want to store chunks while in editor?
            <para>NOTE: You'd also want to implement <see cref="T:Sandbox.Component.ExecuteInEditor"/> on your component.</para>
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.EditorChunks">
            <summary>
            Requires for <see cref="P:Boxfish.BaseVoxelVolume`2.StoreEditorChunks"/> to be true.
            <para>NOTE: You will still have to manually generate chunks with <see cref="M:Boxfish.BaseVoxelVolume`2.GenerateMesh(Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean)"/> for this to store anything.</para>
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.IgnoreOOBFaces">
            <summary>
            Should we ignore out of bounds faces? 
            <para>NOTE: This does not affect the +Z faces.</para>
            <para>NOTE: This does not work 100% well with varying elevation.</para>
            </summary>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.VoxelMesh">
            <summary>
            Shrimple structure containing voxel mesh information such as vertices.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.CreateVertex(Vector3Int,System.Int32,System.Int32,System.Int32,`0)">
            <summary>
            Our method that creates a single vertex based on the parameters.
            </summary>
            <param name="position"></param>
            <param name="vertexIndex"></param>
            <param name="face"></param>
            <param name="ao"></param>
            <param name="voxel"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GenerateMeshes(System.Collections.Generic.IEnumerable{Boxfish.BaseVoxelVolume{`0,`1}.Chunk},System.Boolean)">
            <summary>
            Builds multiple chunk meshes.
            </summary>
            <param name="chunks"></param>
            <param name="physics"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GenerateMeshes(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean}})">
            <summary>
            Builds multiple chunk meshes with each one optionally getting physics.
            </summary>
            <param name="chunks"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GenerateMesh(Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean)">
            <summary>
            Build a chunk mesh.
            </summary>
            <param name="chunk"></param>
            <param name="physics"></param>
            <returns></returns>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Objects">
            <summary>
            All of the chunk objects in this volume.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GetChunkObject(Boxfish.BaseVoxelVolume{`0,`1}.Chunk)">
            <summary>
            Get or create a <see cref="T:Boxfish.BaseVoxelVolume`2.ChunkObject"/>.
            </summary>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.DestroyObjects">
            <summary>
            Go through all ChunkObjects and clear them.
            </summary>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.ChunkObject">
            <summary>
            This is the class for physical chunks in the world.
            <para>We store a <see cref="T:Sandbox.SceneObject"/> and a <see cref="T:Sandbox.PhysicsBody"/> here.</para>
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.SetVoxel(System.Int32,System.Int32,System.Int32,`0,Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean)">
            <summary>
            Set voxel at 3D voxel position.
            <para>NOTE: This will not automatically update the chunk mesh, you will have to re-generate it manually.</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="voxel"></param>
            <param name="relative"></param>
            <param name="createChunk"></param>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.SetVoxel(Vector3Int,`0,Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean)">
            <inheritdoc cref="M:Boxfish.BaseVoxelVolume`2.SetVoxel(System.Int32,System.Int32,System.Int32,`0,Boxfish.BaseVoxelVolume{`0,`1}.Chunk,System.Boolean)" />
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Import(System.String)">
            <summary>
            Import a voxel file by path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.ComputeBounds(System.Collections.Generic.IDictionary{Vector3Int,Boxfish.BaseVoxelVolume{`0,`1}.Chunk})">
            <summary>
            Compute the voxelspace bounds of a collection of chunks.
            <para>NOTE: Uses the volume's chunks by default if no chunks param is assigned.</para>
            </summary>
            <param name="chunks"></param>
            <returns></returns>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.VoxelQueryData">
            <summary>
            The result of queries giving information about a voxel, it's position, etc.. 
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.ApplyWorldTransform(Vector3)">
            <summary>
            Apply our GameObject's transform to a 3D-vector.
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.WorldToVoxel(Vector3,System.Boolean)">
            <summary>
            Converts a world position to a VoxelVolume position.
            </summary>
            <param name="position"></param>
            <param name="transformed"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.VoxelToWorld(Vector3Int,System.Boolean)">
            <summary>
            Converts a VoxelVolume position to a world position.
            </summary>
            <param name="position"></param>
            <param name="transformed"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GetLocalSpace(System.Int32,System.Int32,System.Int32,Boxfish.BaseVoxelVolume{`0,`1}.Chunk@,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)">
            <summary>
            Converts global VoxelVolume coordinates to local, also outs the chunk.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="chunk"></param>
            <param name="relative"></param>
            <returns>The position local to the chunk.</returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GetGlobalSpace(System.Byte,System.Byte,System.Byte,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)">
            <summary>
            Converts local coordinates of a chunk to global coordinates in a VoxelWorld.
            <para>NOTE: The position range expected is 0-15.</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="relative"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Query(System.Int32,System.Int32,System.Int32,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)">
            <summary>
            Gets VoxelQueryData by offset relative to a chunk, or Chunks[0, 0, 0].
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="relative"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.Query(Vector3Int,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)">
            <inheritdoc cref="M:Boxfish.BaseVoxelVolume`2.Query(System.Int32,System.Int32,System.Int32,Boxfish.BaseVoxelVolume{`0,`1}.Chunk)"/>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.TransformMatrix">
            <summary>
            Our transform matrix, uses the GameObject's World transforms.
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Scale">
            <summary>
            Scale of our voxels.
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Material">
            <summary>
            The material we want to use for our chunks.
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Collisions">
            <summary>
            Should we generate collisions?
            </summary>
        </member>
        <member name="P:Boxfish.BaseVoxelVolume`2.Layout">
            <summary>
            Our vertex layout.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.IsValidVoxel(`0)">
            <summary>
            We need this to determine the if this voxel solid or not, because our Voxels are structs. 
            </summary>
            <param name="voxel"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.IsOpaqueVoxel(`0)">
            <summary>
            We need this to determine the if this voxel opaque or not, for rendering non-opaque voxels that are directly behind opaque voxels. 
            </summary>
            <param name="voxel"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.SetAttributes(Sandbox.RenderAttributes)">
            <summary>
            This is called for every chunk <see cref="T:Sandbox.SceneObject"/>'s <see cref="T:Sandbox.RenderAttributes"/>.
            </summary>
            <param name="attributes"></param>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.AStarNode">
            <summary>
            We store information about A* nodes and some utility methods inside of this class.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarNode.GetNeighbours">
            <summary>
            Get all neighbouring voxels, even ones we can jump on or land down
            </summary>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarNode.Distance(Boxfish.BaseVoxelVolume{`0,`1}.AStarNode)">
            <summary>
            Get the distance between the node's voxel's position
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarNode.HorizontalDistance(Boxfish.BaseVoxelVolume{`0,`1}.AStarNode)">
            <summary>
            Get the horizontal distance between the node's voxel's position
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarNode.GetNeighbourInDirection(Vector3)">
            <summary>
            Returns the neighbour in that direction
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="T:Boxfish.BaseVoxelVolume`2.AStarPath">
            <summary>
            This struct defines the path full A* path.
            </summary>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarPath.GetLength">
            <summary>
            Return the total length of the path
            </summary>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.AStarPath.Simplify(System.Int32,System.Int32)">
            <summary>
            Simplify the path by iterating over line of sights between the given segment size, joining them if valid
            </summary>
            <param name="segmentAmounts"></param>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.IsAboveFree(Vector3Int,System.Int32)">
            <summary>
            Check if there's only air above
            </summary>
            <param name="position"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.GetClosestWalkable(Vector3Int,System.Int32,System.Threading.CancellationTokenSource)">
            <summary>
            Find the nearest walkable voxel, EXPENSIVE! Only checks below, no reason to check up
            </summary>
            <param name="point"></param>
            <param name="maxDistance"></param>
            <param name="possibleTokenSource"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.BaseVoxelVolume`2.ComputePath(Boxfish.BaseVoxelVolume{`0,`1}.AStarNode,Boxfish.BaseVoxelVolume{`0,`1}.AStarNode,System.Threading.CancellationToken,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Computes a path from the starting point to a target point. Reversing the path if needed.
            </summary>
            <param name="startNode">The starting point of the path.</param>
            <param name="endNode">The desired destination point of the path.</param>
            <param name="token">A cancellation token used to cancel computing the path.</param>
            <param name="maxDistance">Max distance it will search for, then will just approach the closest point</param>
            <param name="acceptPartial">If it doesn't find the target, return the closest node found</param>
            <param name="reversed">Whether or not to reverse the resulting path.</param>
            <returns>A path</returns>
        </member>
        <member name="T:Boxfish.VoxelBounds">
            <summary>
            Just a shrimple struct with a Vector3Int min and max value.
            </summary>
        </member>
        <member name="T:Boxfish.VoxelFormat">
            <summary>
            Derive from this to add your own importers.
            </summary>
        </member>
        <member name="P:Boxfish.VoxelFormat.Extensions">
            <summary>
            Array of all supported extensions for this format.
            </summary>
        </member>
        <member name="M:Boxfish.VoxelFormat.Parse``2(System.Byte[],Boxfish.VoxelImporter)">
            <summary>
            This method is executed during the BuildAsync process of <see cref="T:Boxfish.VoxelImporter"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="rawData"></param>
            <param name="importer"></param>
            <returns></returns>
        </member>
        <member name="T:Boxfish.IColorImporter`1">
            <summary>
            Implement this struct on your own voxel struct if you want to import with the Boxfish importers.
            </summary>
            <typeparam name="T">Same types as your Voxel.</typeparam>
        </member>
        <member name="T:Boxfish.VoxelImporter">
            <summary>
            Our builder struct for importing voxel models.
            </summary>
        </member>
        <member name="M:Boxfish.VoxelImporter.FromPath(System.String)">
            <summary>
            Begin building map data from a file path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.VoxelImporter.WithFormat``1">
            <summary>
            Override the format of this builder.
            </summary>
            <typeparam name="U"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Boxfish.VoxelImporter.BuildAsync``2">
            <summary>
            Build voxel data from the map data asynchronously.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Boxfish.Library.AtlasResource">
            <summary>
            A resource containing textures for a <see cref="T:Boxfish.Library.VoxelVolume"/>.
            <para>See https://sbox.game/boxfish/ or README.md for more explanation.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.UseRegion">
            <summary>
            Do we cut out a region out of the RegionAtlas?
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.Texture">
            <summary>
            Do we want to load this texture directly from an image?
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.Region">
            <summary>
            The region that we cut out from the RegionAtlas in pixels.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.Opaque">
            <summary>
            Is our voxel opaque? 
            <para>This determines if we should render voxels that are directly behind it.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.OnBlockPlaced">
            <summary>
            Called when a block is broken.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.OnBlockBroken">
            <summary>
            Called when a block is broken.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.Data">
            <inheritdoc cref="P:Boxfish.Library.AtlasResource.AtlasItem._data" />
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem._data">
            /// <summary>
            Container for an atlas item's custom data.
            <para>You can use this for embedding stuff like health, or step sounds inside the atlas item itself, then fetching those values through code.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.AtlasItem.Index">
            <summary>
            The index of our atlas item.
            </summary>
        </member>
        <member name="M:Boxfish.Library.AtlasResource.AtlasItem.GetData(System.String,System.String)">
            <summary>
            Get data by key, or default, if key doesn't exist.
            </summary>
            <param name="key"></param>
            <param name="default"></param>
            <returns></returns>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.Items">
            <inheritdoc cref="P:Boxfish.Library.AtlasResource._items" />
        </member>
        <member name="P:Boxfish.Library.AtlasResource.Texture">
            <summary>
            The compiled texture of this atlas.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.RegionAtlas">
            <summary>
            Optional texture atlas used for regions.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource.Size">
            <summary>
            Size of each face's texture.
            </summary>
        </member>
        <member name="P:Boxfish.Library.AtlasResource._items">
            <summary>
            List of all the items in our atlas.
            </summary>
        </member>
        <member name="M:Boxfish.Library.AtlasResource.TryFindByName(System.String,System.UInt16@)">
            <summary>
            Look for an atlas item with the exact name.
            </summary>
            <param name="name"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.Library.AtlasResource.TryGet(System.Int32,Boxfish.Library.AtlasResource.AtlasItem@)">
            <summary>
            Try get a specific atlas item by index.
            </summary>
            <param name="index"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Boxfish.Library.AtlasResource.Get(System.Int32)">
            <summary>
            Get a specific atlas item at index.
            <para>NOTE: Can return null if index not within bounds.</para>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Boxfish.Library.NetworkedVoxelVolume">
            <summary>
            A networked voxel volume component.
            <para>Remember to make your GameObject networked, and use the <see cref="M:Boxfish.Library.NetworkedVoxelVolume.BroadcastSet(Vector3Int,Boxfish.Library.Voxel)"/> etc.. methods to apply voxel changes!</para>
            <para>NOTE: You should inherit this component if you want to serialize a volume with something such as world generation..</para>
            </summary>
        </member>
        <member name="M:Boxfish.Library.NetworkedVoxelVolume.BroadcastSetRadius(Vector3Int,System.Single,Boxfish.Library.Voxel)">
            <summary>
            Set a radius of voxels and broadcast the change to other clients.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
            <param name="voxel"></param>
        </member>
        <member name="M:Boxfish.Library.NetworkedVoxelVolume.BroadcastSetBounds(Vector3Int,Boxfish.VoxelBounds,Boxfish.Library.Voxel)">
            <summary>
            Set a bounds of voxels and broadcast the change to other clients.
            </summary>
            <param name="position"></param>
            <param name="bounds"></param>
            <param name="voxel"></param>
        </member>
        <member name="M:Boxfish.Library.NetworkedVoxelVolume.BroadcastSet(Vector3Int,Boxfish.Library.Voxel)">
            <summary>
            Set a singular voxel and broadcast the change to other clients.
            </summary>
            <param name="position"></param>
            <param name="voxel"></param>
        </member>
        <member name="M:Boxfish.Library.NetworkedVoxelVolume.Serialize">
            <summary>
            This is called by the host to serialize the current world and send it to the connecting client.
            <para>NOTE: You should override this if you're doing something like: world generation... This can get expensive fast!</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Boxfish.Library.NetworkedVoxelVolume.Deserialize(System.Byte[])">
            <summary>
            This is called upon snapshot loading, we apply the snapshot data to the world here.
            <para>NOTE: You should override this if you're doing something like: world generation... This can get expensive fast!</para>
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:Boxfish.Library.Voxel">
            <summary>
            Default voxel struct used for the <see cref="T:Boxfish.Library.VoxelVolume"/> component.
            </summary>
        </member>
        <member name="F:Boxfish.Library.Voxel.Empty">
            <summary>
            A static reference to an empty readonly voxel.
            </summary>
        </member>
        <member name="F:Boxfish.Library.Voxel.Texture">
            <summary>
            The index of our voxel's texture in our atlas.
            <para>NOTE: We only have 12-bits of numbers available, so the max amount of textures is 4096.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.Voxel.Color">
            <summary>
            The Color32 value of this voxel, NOTE: the alpha channel is ignored.
            </summary>
        </member>
        <member name="T:Boxfish.Library.VoxelVolume">
            <summary>
            Example voxel volume component.
            <para>If you want more freedom, see <see cref="T:Boxfish.BaseVoxelVolume`2"/> instead.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.VoxelVolume.UpdateFrequency">
            <summary>
            The frequency of chunk mesh updates, should be somewhere around 1 / 30f (used for <see cref="M:Boxfish.Library.VoxelVolume.TickUpdate"/>).
            <para>NOTE: Set to 0 to completely ignore updates.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.VoxelVolume.SinceUpdate">
            <summary>
            The time passed since <see cref="M:Boxfish.Library.VoxelVolume.TickUpdate"/> has been called.
            </summary>
        </member>
        <member name="F:Boxfish.Library.VoxelVolume.TrackedChanges">
            <summary>
            Which chunks have been tracked to change.
            </summary>
        </member>
        <member name="M:Boxfish.Library.VoxelVolume.TrackChange(Boxfish.BaseVoxelVolume{Boxfish.Library.Voxel,Boxfish.Library.VoxelVertex}.Chunk,System.Boolean,System.Nullable{System.ValueTuple{System.Byte,System.Byte,System.Byte}})">
            <summary>
            Track a voxel change, we will go through these in <see cref="M:Boxfish.Library.VoxelVolume.TickUpdate"/>.
            </summary>
            <param name="chunk"></param>
            <param name="changed"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Boxfish.Library.VoxelVolume.SetTrackedVoxel(Vector3Int,Boxfish.Library.Voxel,Boxfish.BaseVoxelVolume{Boxfish.Library.Voxel,Boxfish.Library.VoxelVertex}.Chunk)">
            <summary>
            Set a voxel and track the change, this will automatically regenerate chunks if you have ticked updates enabled.
            </summary>
            <param name="position"></param>
            <param name="voxel"></param>
            <param name="relative"></param>
        </member>
        <member name="M:Boxfish.Library.VoxelVolume.SetTrackedVoxel(System.Int32,System.Int32,System.Int32,Boxfish.Library.Voxel,Boxfish.BaseVoxelVolume{Boxfish.Library.Voxel,Boxfish.Library.VoxelVertex}.Chunk)">
            <inheritdoc cref="M:Boxfish.Library.VoxelVolume.SetTrackedVoxel(Vector3Int,Boxfish.Library.Voxel,Boxfish.BaseVoxelVolume{Boxfish.Library.Voxel,Boxfish.Library.VoxelVertex}.Chunk)"/>
        </member>
        <member name="M:Boxfish.Library.VoxelVolume.TickUpdate">
            <summary>
            Tick update the changed chunks.
            <para>NOTE: This will update the chunks directly, you shouldn't call this multiple times a frame.</para>
            </summary>
        </member>
        <member name="P:Boxfish.Library.VoxelVolume.Atlas">
            <summary>
            The reference to our atlas.
            </summary>
        </member>
        <member name="P:Boxfish.Library.VoxelVolume.VoxelScale">
            <summary>
            The scale of our voxels in inches.
            <para>Defaulted to 1 meter.</para>
            </summary>
        </member>
        <member name="M:Boxfish.Library.VoxelVolume.UpdateObjects">
            <summary>
            Call this to update all attributes and transforms on ChunkObjects.
            </summary>
        </member>
        <member name="T:Boxfish.Utility.AmbientOcclusion">
            <summary>
            A little helper static class for looking up baked AO values.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.AmbientOcclusion.Fetch``2(Boxfish.BaseVoxelVolume{``0,``1}.Chunk,Vector3Int,System.Int32,System.Int32)">
            <summary>
            Builds AO values for a voxel based on the parameters.
            </summary>
            <param name="chunk"></param>
            <param name="localPos"></param>
            <param name="face"></param>
            <param name="vertex"></param>
            <returns>A value between 0 and 3 determining the ambient occlusion strength for a vertex.</returns>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.Add(Vector3)">
            <summary>
            Add a vertex.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. 
            This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddTriangle(Vector3,Vector3,Vector3)">
            <summary>
            Add a triangle to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddQuad(Vector3,Vector3,Vector3,Vector3)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddQuad(Ray,Vector3,Vector3)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Boxfish.Utility.VertexBuffer.AddCube(Vector3,Vector3,Rotation)">
            <summary>
            Add a cube to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="T:Boxfish.Utility.VoxelUtils">
            <summary>
            A static class containing constants and other utility.
            </summary>
        </member>
        <member name="F:Boxfish.Utility.VoxelUtils.FaceIndices">
            <summary>
            Indices for cube faces.
            </summary>
        </member>
        <member name="F:Boxfish.Utility.VoxelUtils.Directions">
            <summary>
            Directions for each face.
            </summary>
        </member>
        <member name="F:Boxfish.Utility.VoxelUtils.Positions">
            <summary>
            The offsets for each face of a cube.
            </summary>
        </member>
    </members>
</doc>
